<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.0">
<title>phiml.math.magic API documentation</title>
<meta name="description" content="Magic methods allow custom classes to be compatible with various functions defined in `phiml.math`, analogous to how implementing `__hash__` allows …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>phiml.math.magic</code></h1>
</header>
<section id="section-intro">
<p>Magic methods allow custom classes to be compatible with various functions defined in <code><a title="phiml.math" href="index.html">phiml.math</a></code>, analogous to how implementing <code>__hash__</code> allows objects to be used with <code>hash()</code>.
The magic methods are grouped into purely declarative classes (interfaces) by what functionality they provide.</p>
<ul>
<li><code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code> objects have a <code><a title="phiml.math.Shape" href="index.html#phiml.math.Shape">Shape</a></code>.</li>
<li><code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> objects can be sliced along dimensions.</li>
<li><code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> objects can additionally be reshaped.</li>
<li><code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> objects can be disassembled into tensors.</li>
</ul>
<p>All of these magic classes declared here define a custom instance checks and should not be used as superclasses.</p>
<p>An object implements one of the types defined here by implementing one or more of the related magic methods.
Instance checks can be performed via <code>isinstance(obj, &lt;MagicClass&gt;)</code>.</p>
<p>This is analogous to interfaces defined in the built-in <code>collections</code> package, such as <code>Sized, Iterable, Hashable, Callable</code>.
To check whether <code>len(obj)</code> can be performed, you check <code>isinstance(obj, Sized)</code>.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="phiml.math.magic.slicing_dict"><code class="name flex">
<span>def <span class="ident">slicing_dict</span></span>(<span>obj, item, existing_only=True) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Creates a slicing <code>dict</code> from <code>item</code> where <code>item</code> is an arbitrary value passed to <code>__getitem__()</code>.</p>
<p><code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> objects should call this function inside <code>__getitem__()</code>, passing <code>self</code> and <code>item</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd>Object to be sliced.</dd>
<dt><strong><code>item</code></strong></dt>
<dd>Slices.</dd>
<dt><strong><code>existing_only</code></strong></dt>
<dd>Whether to include dims in the slicing dict which are present on <code>obj</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>dict</code> mapping dimension names to slices.</p></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="phiml.math.magic.BoundDim"><code class="flex name class">
<span>class <span class="ident">BoundDim</span></span>
<span>(</span><span>obj, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a dimension of a sliceable object to make slicing, renaming and retyping prettier.
Any instance of <code><a title="phiml.math.magic.BoundDim" href="#phiml.math.magic.BoundDim">BoundDim</a></code> is bound to the sliceable object and is immutable.
All operations upon the dim affect return a copy of the sliceable object.</p>
<p><code><a title="phiml.math.magic.BoundDim" href="#phiml.math.magic.BoundDim">BoundDim</a></code> objects are generally created by and for objects that are <code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> (and therefore also <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code>).
These objects should declare the following method to support the <code>.dim</code> syntax:</p>
<pre><code class="language-python">from phiml.math.magic import BoundDim

class MyClass:

    def __getattr__(self, name: str) -&gt; BoundDim:
        return BoundDim(self, name)
</code></pre>
<p><strong>Usage</strong></p>
<ul>
<li><code>obj.dim.size</code> returns the dimension size.</li>
<li><code>obj.dim.labels</code> returns the dimension labels.</li>
<li><code>obj.dim.exists</code> checks whether a dimension is listed in the shape of the bound object.</li>
<li><code>obj.dim[0]</code> picks the first element along <code>dim</code>. The shape of the result will not contain <code>dim</code>.</li>
<li><code>obj.dim[1:-1]</code> discards the first and last element along <code>dim</code>.</li>
<li><code>obj.dim.rename('new_name')</code> renames <code>dim</code> to <code>new_name</code>.</li>
<li><code>obj.dim.as_channel()</code> changes the type of <code>dim</code> to <em>channel</em>.</li>
<li><code>obj.dim.unstack()</code> un-stacks the bound value along <code>dim</code>.</li>
<li><code>for slice in obj.dim</code> loops over all slices of <code>dim</code>.</li>
</ul>
<p>Multiple dimensions can also be chained together using <code>obj.dim1.dim2&hellip;</code>.
This supports the following operations:</p>
<ul>
<li><code>obj.dim1.dim2&hellip;volume</code> returns the product of the sizes</li>
<li><code>obj.dim1.dim2...[0, -1]</code> takes the first element along <code>dim1</code> and the last element along <code>dim2</code></li>
<li><code>obj.dim1.dim2&hellip;pack(new_dim)</code> packs the dimensions into a new dimension with size equal to their volume</li>
<li><code>obj.dim1.dim2&hellip;unstack()</code> un-stacks <code>obj</code> along multiple dimensions</li>
<li><code>obj.dim1.dim2&hellip;retype(type)</code> Changes the type of all selected dimensions</li>
<li><code>for slice in obj.dim1.dim2&hellip;</code> loops over all slices as if unstacking first</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>obj</code></strong></dt>
<dd><code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> bound object.</dd>
<dt><strong><code>name</code></strong></dt>
<dd>Dimension name as <code>str</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BoundDim:
    &#34;&#34;&#34;
    Represents a dimension of a sliceable object to make slicing, renaming and retyping prettier.
    Any instance of `BoundDim` is bound to the sliceable object and is immutable.
    All operations upon the dim affect return a copy of the sliceable object.

    `BoundDim` objects are generally created by and for objects that are `Sliceable` (and therefore also `Shaped`).
    These objects should declare the following method to support the `.dim` syntax:

    ```python
    from phiml.math.magic import BoundDim

    class MyClass:

        def __getattr__(self, name: str) -&gt; BoundDim:
            return BoundDim(self, name)
    ```

    **Usage**

    * `obj.dim.size` returns the dimension size.
    * `obj.dim.labels` returns the dimension labels.
    * `obj.dim.exists` checks whether a dimension is listed in the shape of the bound object.
    * `obj.dim[0]` picks the first element along `dim`. The shape of the result will not contain `dim`.
    * `obj.dim[1:-1]` discards the first and last element along `dim`.
    * `obj.dim.rename(&#39;new_name&#39;)` renames `dim` to `new_name`.
    * `obj.dim.as_channel()` changes the type of `dim` to *channel*.
    * `obj.dim.unstack()` un-stacks the bound value along `dim`.
    * `for slice in obj.dim` loops over all slices of `dim`.

    Multiple dimensions can also be chained together using `obj.dim1.dim2...`.
    This supports the following operations:

    * `obj.dim1.dim2...volume` returns the product of the sizes
    * `obj.dim1.dim2...[0, -1]` takes the first element along `dim1` and the last element along `dim2`
    * `obj.dim1.dim2...pack(new_dim)` packs the dimensions into a new dimension with size equal to their volume
    * `obj.dim1.dim2...unstack()` un-stacks `obj` along multiple dimensions
    * `obj.dim1.dim2...retype(type)` Changes the type of all selected dimensions
    * `for slice in obj.dim1.dim2...` loops over all slices as if unstacking first
    &#34;&#34;&#34;

    def __init__(self, obj, name: str):
        &#34;&#34;&#34;
        Args:
            obj: `Sliceable` bound object.
            name: Dimension name as `str`.
        &#34;&#34;&#34;
        if name.startswith(&#39;_&#39;) or &#39;,&#39; in name or &#39; &#39; in name:
            raise AttributeError(f&#34;&#39;{type(obj)}&#39; object has no attribute &#39;{name}&#39;&#34;)
        if name == &#39;shape&#39;:
            raise AttributeError(f&#34;Object of type {type(obj)} has no shape&#34;)
        if name == &#39;is_tensor_like&#39;:
            raise AttributeError(f&#34;Trying to access {type(obj)}.is_tensor_like which does not exist. This is likely a TensorFlow JIT compile check. This name is reserved.&#34;)
        if DEBUG_CHECKS:
            assert isinstance(obj, Sliceable) and isinstance(obj, Shaped), f&#34;Cannot create BoundDim for {type(obj).__name__}. Objects must be Sliceable and Shaped, see https://tum-pbs.github.io/PhiML/phiml/math/magic.html&#34;
        self.obj = obj
        self.name = name

    @property
    def dual(self):
        return BoundDim(self.obj, &#39;~&#39; + self.name)

    @property
    def exists(self):
        &#34;&#34;&#34; Whether the dimension is listed in the `Shape` of the object. &#34;&#34;&#34;
        return self.name in shape(self.obj)

    def __repr__(self):
        if self.name not in shape(self.obj):
            return f&#34;{type(self.obj).__name__}.{self.name} (non-existent)&#34;
        labels = self.labels
        if labels is not None:
            if len(labels) &lt;= 4:
                size_repr = &#34;,&#34;.join(labels)
            else:
                size_repr = f&#34;{self.size}:{labels[0]}..{labels[-1]}&#34;
        else:
            size_repr = self.size
        from ._shape import SUPERSCRIPT
        return f&#34;{type(self.obj).__name__}.{self.name}{SUPERSCRIPT.get(self.type.__name__, &#39;?&#39;)}={size_repr}&#34;

    @property
    def size(self):
        &#34;&#34;&#34; Length of this dimension as listed in the `Shape` of the bound object. &#34;&#34;&#34;
        return shape(self.obj).get_size(self.name) if self.exists else None

    volume = size

    @property
    def size_or_1(self):
        return shape(self.obj).get_size(self.name) if self.exists else 1

    @property
    def type(self) -&gt; Callable:
        &#34;&#34;&#34;
        The dimension type of this bound dimension. Must be one of `batch`, `spatial`, `instance`, `channel`.

        Returns:

        &#34;&#34;&#34;
        return shape(self.obj)[self.name].type

    @property
    def labels(self):
        return shape(self.obj).get_labels(self.name)

    item_names = labels

    @property
    def item_name_list(self):
        return list(shape(self.obj).get_labels(self.name))

    @property
    def name_tensor(self):
        dim = shape(self.obj)[self.name]
        from ._tensors import wrap
        return wrap(dim.labels[0], dim)

    def __getitem__(self, item):
        return self.obj[{self.name: item}]

    def __setitem__(self, key, value):
        self.obj[{self.name: key}] = value

    def __getattr__(self, item):
        return _BoundDims(self.obj, (self.name, item))

    def keys(self):
        &#34;&#34;&#34;
        Allows unstacking with labels as `dict(**obj.dim)`.

        Returns:
            Sequence of labels or indices.
        &#34;&#34;&#34;
        if not self.exists:
            raise SyntaxError(f&#34;Cannot get labels of nonexistent dim &#39;{self.name}&#39;. shape={shape(self.obj)}&#34;)
        if self.labels is not None:
            return self.labels
        else:
            return range(self.size)

    def unstack(self, size: Union[int, None] = None) -&gt; tuple:
        &#34;&#34;&#34;
        Lists the slices along this dimension as a `tuple`.

        Args:
            size: (optional) If given as `int`, this dimension can be unstacked even if it is not present on the object.
                In that case, `size` copies of the object are returned.

        Returns:
            `tuple` of `Sliceable`
        &#34;&#34;&#34;
        from ._magic_ops import unstack
        if size is None:
            return unstack(self.obj, self.name)
        else:
            if self.exists:
                unstacked = unstack(self.obj, self.name)
                assert len(unstacked) == size, f&#34;Size of dimension {self.name} does not match {size}.&#34;
                return unstacked
            else:
                return (self.obj,) * size

    def __iter__(self):
        &#34;&#34;&#34; Iterate over slices along this dim &#34;&#34;&#34;
        if self.exists:
            return iter(self.unstack())
        else:
            return iter([self.obj])

    def items(self):
        keys = self.labels
        if keys is None:
            keys = range(self.size)
        values = self.unstack()
        return {k: v for k, v in zip(keys, values)}.items()

    def __call__(self, *args, **kwargs):
        raise TypeError(f&#34;Method {type(self.obj).__name__}.{self.name}() does not exist.&#34;)

    def rename(self, name: str, **kwargs):
        &#34;&#34;&#34;
        Returns a shallow copy of the `Tensor` where this dimension has the specified name.

        See Also:
            `phiml.math.rename_dims()`
        &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        from ._magic_ops import rename_dims
        return rename_dims(self.obj, self.name, name, **kwargs)

    def retype(self, dim_type: Callable, **kwargs):
        &#34;&#34;&#34;
        Returns a shallow copy of the `Tensor` where this dimension has the specified type.

        See Also:
            `phiml.math.rename_dims()`
        &#34;&#34;&#34;
        new_dim = dim_type(**{self.name: self.labels or self.size})
        from ._magic_ops import rename_dims
        return rename_dims(self.obj, self.name, new_dim, **kwargs)

    as_type = retype

    def as_batch(self, name: str = None):
        &#34;&#34;&#34; Returns a shallow copy of the `Tensor` where the type of this dimension is *batch*. &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        return self.retype(batch) if name is None else self.replace(batch(**{name: self.labels or self.size}))

    def as_spatial(self, name: str = None):
        &#34;&#34;&#34; Returns a shallow copy of the `Tensor` where the type of this dimension is *spatial*. &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        return self.retype(spatial) if name is None else self.replace(spatial(**{name: self.labels or self.size}))

    def as_channel(self, name: str = None):
        &#34;&#34;&#34; Returns a shallow copy of the `Tensor` where the type of this dimension is *channel*. &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        return self.retype(channel) if name is None else self.replace(channel(**{name: self.labels or self.size}))

    def as_instance(self, name: str = None):
        &#34;&#34;&#34; Returns a shallow copy of the `Tensor` where the type of this dimension is *instance*. &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        return self.retype(instance) if name is None else self.replace(instance(**{name: self.labels or self.size}))

    def as_dual(self, name: str = None):
        &#34;&#34;&#34; Returns a shallow copy of the `Tensor` where the type of this dimension is *instance*. &#34;&#34;&#34;
        if not self.exists:
            return self.obj
        return self.retype(dual) if name is None else self.replace(dual(**{name: self.labels or self.size}))

    @property
    def T(self):
        return self.retype(dual) if self.type != dual else self.retype(channel)

    def replace(self, dim: Shape, **kwargs):
        &#34;&#34;&#34;
        Returns a shallow copy of the `Tensor` where this dimension has been replaced by `dim`.

        See Also:
            `phiml.math.rename_dims()`
        &#34;&#34;&#34;
        from ._magic_ops import rename_dims
        return rename_dims(self.obj, self.name, dim, **kwargs)

    def unpack(self, *dims: Shape, **kwargs):
        &#34;&#34;&#34;
        Returns a shallow copy of the `Tensor` where this dimension has been unpacked into `dims`.

        See Also:
            `phiml.math.unpack_dim()`
        &#34;&#34;&#34;
        from ._magic_ops import unpack_dim
        return unpack_dim(self.obj, self.name, *dims, **kwargs)

    def __bool__(self):
        raise SyntaxError(f&#34;{self} cannot be converted to bool. The property you want to access likely does not exist or raised an error when evaluated.&#34;)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li>phiml.math._tensors.TensorDim</li>
</ul>
<h3>Instance variables</h3>
<dl>
<dt id="phiml.math.magic.BoundDim.T"><code class="name">prop <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def T(self):
    return self.retype(dual) if self.type != dual else self.retype(channel)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.dual"><code class="name">prop <span class="ident">dual</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def dual(self):
    return BoundDim(self.obj, &#39;~&#39; + self.name)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.exists"><code class="name">prop <span class="ident">exists</span></code></dt>
<dd>
<div class="desc"><p>Whether the dimension is listed in the <code>Shape</code> of the object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def exists(self):
    &#34;&#34;&#34; Whether the dimension is listed in the `Shape` of the object. &#34;&#34;&#34;
    return self.name in shape(self.obj)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.item_name_list"><code class="name">prop <span class="ident">item_name_list</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def item_name_list(self):
    return list(shape(self.obj).get_labels(self.name))</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.item_names"><code class="name">prop <span class="ident">item_names</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self):
    return shape(self.obj).get_labels(self.name)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.labels"><code class="name">prop <span class="ident">labels</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self):
    return shape(self.obj).get_labels(self.name)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.name_tensor"><code class="name">prop <span class="ident">name_tensor</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name_tensor(self):
    dim = shape(self.obj)[self.name]
    from ._tensors import wrap
    return wrap(dim.labels[0], dim)</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.size"><code class="name">prop <span class="ident">size</span></code></dt>
<dd>
<div class="desc"><p>Length of this dimension as listed in the <code>Shape</code> of the bound object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34; Length of this dimension as listed in the `Shape` of the bound object. &#34;&#34;&#34;
    return shape(self.obj).get_size(self.name) if self.exists else None</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.size_or_1"><code class="name">prop <span class="ident">size_or_1</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size_or_1(self):
    return shape(self.obj).get_size(self.name) if self.exists else 1</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.type"><code class="name">prop <span class="ident">type</span> : Callable</code></dt>
<dd>
<div class="desc"><p>The dimension type of this bound dimension. Must be one of <code>batch</code>, <code>spatial</code>, <code>instance</code>, <code>channel</code>.</p>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def type(self) -&gt; Callable:
    &#34;&#34;&#34;
    The dimension type of this bound dimension. Must be one of `batch`, `spatial`, `instance`, `channel`.

    Returns:

    &#34;&#34;&#34;
    return shape(self.obj)[self.name].type</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.BoundDim.volume"><code class="name">prop <span class="ident">volume</span></code></dt>
<dd>
<div class="desc"><p>Length of this dimension as listed in the <code>Shape</code> of the bound object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def size(self):
    &#34;&#34;&#34; Length of this dimension as listed in the `Shape` of the bound object. &#34;&#34;&#34;
    return shape(self.obj).get_size(self.name) if self.exists else None</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.magic.BoundDim.as_batch"><code class="name flex">
<span>def <span class="ident">as_batch</span></span>(<span>self, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where the type of this dimension is <em>batch</em>.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.as_channel"><code class="name flex">
<span>def <span class="ident">as_channel</span></span>(<span>self, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where the type of this dimension is <em>channel</em>.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.as_dual"><code class="name flex">
<span>def <span class="ident">as_dual</span></span>(<span>self, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where the type of this dimension is <em>instance</em>.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.as_instance"><code class="name flex">
<span>def <span class="ident">as_instance</span></span>(<span>self, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where the type of this dimension is <em>instance</em>.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.as_spatial"><code class="name flex">
<span>def <span class="ident">as_spatial</span></span>(<span>self, name: str = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where the type of this dimension is <em>spatial</em>.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.as_type"><code class="name flex">
<span>def <span class="ident">as_type</span></span>(<span>self, dim_type: Callable, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where this dimension has the specified type.</p>
<p>See Also:
<code><a title="phiml.math.rename_dims" href="index.html#phiml.math.rename_dims">rename_dims()</a></code></p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="phiml.math.magic.BoundDim.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Allows unstacking with labels as <code>dict(**obj.dim)</code>.</p>
<h2 id="returns">Returns</h2>
<p>Sequence of labels or indices.</p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.rename"><code class="name flex">
<span>def <span class="ident">rename</span></span>(<span>self, name: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where this dimension has the specified name.</p>
<p>See Also:
<code><a title="phiml.math.rename_dims" href="index.html#phiml.math.rename_dims">rename_dims()</a></code></p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, dim: phiml.math._shape.Shape, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where this dimension has been replaced by <code>dim</code>.</p>
<p>See Also:
<code><a title="phiml.math.rename_dims" href="index.html#phiml.math.rename_dims">rename_dims()</a></code></p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.retype"><code class="name flex">
<span>def <span class="ident">retype</span></span>(<span>self, dim_type: Callable, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where this dimension has the specified type.</p>
<p>See Also:
<code><a title="phiml.math.rename_dims" href="index.html#phiml.math.rename_dims">rename_dims()</a></code></p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.unpack"><code class="name flex">
<span>def <span class="ident">unpack</span></span>(<span>self, *dims: phiml.math._shape.Shape, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a shallow copy of the <code>Tensor</code> where this dimension has been unpacked into <code>dims</code>.</p>
<p>See Also:
<code><a title="phiml.math.unpack_dim" href="index.html#phiml.math.unpack_dim">unpack_dim()</a></code></p></div>
</dd>
<dt id="phiml.math.magic.BoundDim.unstack"><code class="name flex">
<span>def <span class="ident">unstack</span></span>(<span>self, size: Optional[int] = None) ‑> tuple</span>
</code></dt>
<dd>
<div class="desc"><p>Lists the slices along this dimension as a <code>tuple</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>size</code></strong></dt>
<dd>(optional) If given as <code>int</code>, this dimension can be unstacked even if it is not present on the object.
In that case, <code>size</code> copies of the object are returned.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of <code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="phiml.math.magic.OtherMagicFunctions"><code class="flex name class">
<span>class <span class="ident">OtherMagicFunctions</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OtherMagicFunctions:

    def __cast__(self, dtype: DType):
        raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="phiml.math.magic.PhiTreeNode"><code class="flex name class">
<span>class <span class="ident">PhiTreeNode</span></span>
</code></dt>
<dd>
<div class="desc"><p>Φ-tree nodes can be iterated over and disassembled or flattened into elementary objects, such as tensors.
<code><a title="phiml.math.Tensor" href="index.html#phiml.math.Tensor">Tensor</a></code> instances as well as PyTree nodes (<code>tuple</code>, <code>list</code>, <code>dict</code> with <code>str</code> keys) are Φ-tree nodes.
All data classes are also considered PhiTreeNodes as of version 2.3.</p>
<p>For custom classes to be considered Φ-tree nodes, they have to be a dataclass or implement one of the following magic methods:</p>
<ul>
<li><code>__variable_attrs__()</code></li>
<li><code>__value_attrs__()</code></li>
</ul>
<p>Dataclasses may also implement these functions to specify which attributes should be considered value / variable properties.</p>
<p>Additionally, Φ-tree nodes must override <code>__eq__()</code> to allow comparison of data-stripped (key) instances.</p>
<p>To check whether an object is a Φ-tree node, use <code>isinstance(obj, <a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a>)</code>.</p>
<p><strong>Usage in <code><a title="phiml.math" href="index.html">phiml.math</a></code>:</strong></p>
<p>Φ-tree nodes can be used as keys, for example in <code>jit_compile()</code>.
They are converted to keys by stripping all variable tensors and replacing them by a placeholder object.
In key mode, <code>__eq__()</code> compares all non-variable properties that might invalidate a trace when changed.</p>
<p>Disassembly and assembly of Φ-tree nodes uses <code><a title="phiml.math.copy_with" href="index.html#phiml.math.copy_with">replace()</a></code> which will call <code>__with_attrs__</code> if implemented.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class PhiTreeNode(metaclass=_PhiTreeNodeType):
    &#34;&#34;&#34;
    Φ-tree nodes can be iterated over and disassembled or flattened into elementary objects, such as tensors.
    `phiml.math.Tensor` instances as well as PyTree nodes (`tuple`, `list`, `dict` with `str` keys) are Φ-tree nodes.
    All data classes are also considered PhiTreeNodes as of version 2.3.

    For custom classes to be considered Φ-tree nodes, they have to be a dataclass or implement one of the following magic methods:

    * `__variable_attrs__()`
    * `__value_attrs__()`

    Dataclasses may also implement these functions to specify which attributes should be considered value / variable properties.

    Additionally, Φ-tree nodes must override `__eq__()` to allow comparison of data-stripped (key) instances.

    To check whether an object is a Φ-tree node, use `isinstance(obj, PhiTreeNode)`.

    **Usage in `phiml.math`:**

    Φ-tree nodes can be used as keys, for example in `jit_compile()`.
    They are converted to keys by stripping all variable tensors and replacing them by a placeholder object.
    In key mode, `__eq__()` compares all non-variable properties that might invalidate a trace when changed.

    Disassembly and assembly of Φ-tree nodes uses `phiml.math.copy_with` which will call `__with_attrs__` if implemented.
    &#34;&#34;&#34;

    def __value_attrs__(self) -&gt; Tuple[str, ...]:
        &#34;&#34;&#34;
        Returns all `Tensor` or `PhiTreeNode` attribute names of `self` that should be transformed by single-operand math operations,
        such as `sin()`, `exp()`.
        Optimization functions, such as `minimize` also work on value attributes, as well as most derivative-related function, e.g.
        - `jacobian()`
        - `custom_gradient()`

        Dataclasses may instead declare the field `values: Tuple[str,...]`

        Returns:
            `tuple` of `str` attributes.
                Calling `getattr(self, attr)` must return a `Tensor` or `PhiTreeNode` for all returned attributes.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __variable_attrs__(self) -&gt; Tuple[str, ...]:
        &#34;&#34;&#34;
        Returns all `Tensor` or `PhiTreeNode` attribute names of `self` whose values are variable.
        Variables denote values that can change from one function call to the next or for which gradients can be recorded.
        If this method is not implemented, all attributes returned by `__value_attrs__()` are considered variable.

        The returned properties are used by the following functions:

        - `jit_compile()`
        - `jit_compile_linear()`
        - `stop_gradient()`

        Dataclasses may instead declare the field `variables: Tuple[str,...]`

        Returns:
            `tuple` of `str` attributes.
                Calling `getattr(self, attr)` must return a `Tensor` or `PhiTreeNode` for all returned attributes.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __all_attrs__(self) -&gt; Tuple[str, ...]:
        &#34;&#34;&#34;
        Returns all `Tensor` or `PhiTreeNode` attribute names of `self` needed to fully describe this instance.
        Fields which never hold `Tensor` instances (directly or indirectly) should not be included.

        The returned attributes are used to extract tensors for serializing and un-serializing the object.

        All names returned by `__variable_attrs__` and `__value_attrs__` must be included in this list.
        If not implemented, the union of `__variable_attrs__` and `__value_attrs__` will be used instead, and dataclasses default to all fields possibly containing data.
        The only dataclass fields excluded are those of type `Shape` or primitive types `str`, `int`, `float`, etc. and collections of these.

        Returns:
            `tuple` of `str` attributes.
                Calling `getattr(self, attr)` must return a `Tensor` or `PhiTreeNode` for all returned attributes.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __with_attrs__(self, **attrs):
        &#34;&#34;&#34;
        Used by `phiml.math.copy_with`.
        Create a copy of this object which has the `Tensor` or `PhiTreeNode` attributes contained in `attrs` replaced.
        If this method is not implemented, tensor attributes are replaced using `setattr()`.

        Args:
            **attrs: `dict` mapping `str` attribute names to `Tensor` or `PhiTreeNode`.

        Returns:
            Altered copy of `self`
        &#34;&#34;&#34;
        raise NotImplementedError

    def __eq__(self, other):
        raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.magic.PhiTreeNode.__all_attrs__"><code class="name flex">
<span>def <span class="ident">__all_attrs__</span></span>(<span>self) ‑> Tuple[str, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> attribute names of <code>self</code> needed to fully describe this instance.
Fields which never hold <code>Tensor</code> instances (directly or indirectly) should not be included.</p>
<p>The returned attributes are used to extract tensors for serializing and un-serializing the object.</p>
<p>All names returned by <code>__variable_attrs__</code> and <code>__value_attrs__</code> must be included in this list.
If not implemented, the union of <code>__variable_attrs__</code> and <code>__value_attrs__</code> will be used instead, and dataclasses default to all fields possibly containing data.
The only dataclass fields excluded are those of type <code>Shape</code> or primitive types <code>str</code>, <code>int</code>, <code>float</code>, etc. and collections of these.</p>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of <code>str</code> attributes.
Calling <code>getattr(self, attr)</code> must return a <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> for all returned attributes.</p></div>
</dd>
<dt id="phiml.math.magic.PhiTreeNode.__value_attrs__"><code class="name flex">
<span>def <span class="ident">__value_attrs__</span></span>(<span>self) ‑> Tuple[str, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> attribute names of <code>self</code> that should be transformed by single-operand math operations,
such as <code>sin()</code>, <code>exp()</code>.
Optimization functions, such as <code>minimize</code> also work on value attributes, as well as most derivative-related function, e.g.
- <code>jacobian()</code>
- <code>custom_gradient()</code></p>
<p>Dataclasses may instead declare the field <code>values: Tuple[str,...]</code></p>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of <code>str</code> attributes.
Calling <code>getattr(self, attr)</code> must return a <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> for all returned attributes.</p></div>
</dd>
<dt id="phiml.math.magic.PhiTreeNode.__variable_attrs__"><code class="name flex">
<span>def <span class="ident">__variable_attrs__</span></span>(<span>self) ‑> Tuple[str, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Returns all <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> attribute names of <code>self</code> whose values are variable.
Variables denote values that can change from one function call to the next or for which gradients can be recorded.
If this method is not implemented, all attributes returned by <code>__value_attrs__()</code> are considered variable.</p>
<p>The returned properties are used by the following functions:</p>
<ul>
<li><code>jit_compile()</code></li>
<li><code>jit_compile_linear()</code></li>
<li><code>stop_gradient()</code></li>
</ul>
<p>Dataclasses may instead declare the field <code>variables: Tuple[str,...]</code></p>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of <code>str</code> attributes.
Calling <code>getattr(self, attr)</code> must return a <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> for all returned attributes.</p></div>
</dd>
<dt id="phiml.math.magic.PhiTreeNode.__with_attrs__"><code class="name flex">
<span>def <span class="ident">__with_attrs__</span></span>(<span>self, **attrs)</span>
</code></dt>
<dd>
<div class="desc"><p>Used by <code><a title="phiml.math.copy_with" href="index.html#phiml.math.copy_with">replace()</a></code>.
Create a copy of this object which has the <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code> attributes contained in <code>attrs</code> replaced.
If this method is not implemented, tensor attributes are replaced using <code>setattr()</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>**attrs</code></strong></dt>
<dd><code>dict</code> mapping <code>str</code> attribute names to <code>Tensor</code> or <code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Altered copy of <code>self</code></p></div>
</dd>
</dl>
</dd>
<dt id="phiml.math.magic.Shapable"><code class="flex name class">
<span>class <span class="ident">Shapable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Shapable objects can be stacked, concatenated and reshaped.</p>
<p>To be considered <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code>, objects must be <code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> and <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code> and implement</p>
<ul>
<li><code>__stack__()</code> or</li>
<li><code>__concat__()</code> and <code>__expand__()</code>.</li>
</ul>
<p>Objects should additionally implement the other magic methods for performance reasons.</p>
<p><strong>Usage in <code><a title="phiml.math" href="index.html">phiml.math</a></code>:</strong></p>
<p>Shapable objects can be used with the following functions in addition to what they inherit from being <code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> and <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code>:</p>
<ul>
<li><code><a title="phiml.math.stack" href="index.html#phiml.math.stack">stack()</a></code></li>
<li><code><a title="phiml.math.concat" href="index.html#phiml.math.concat">concat()</a></code></li>
<li><code><a title="phiml.math.expand" href="index.html#phiml.math.expand">expand()</a></code></li>
<li><code><a title="phiml.math.rename_dims" href="index.html#phiml.math.rename_dims">rename_dims()</a></code></li>
<li><code><a title="phiml.math.pack_dims" href="index.html#phiml.math.pack_dims">pack_dims()</a></code></li>
<li><code><a title="phiml.math.unpack_dim" href="index.html#phiml.math.unpack_dim">unpack_dim()</a></code></li>
<li><code><a title="phiml.math.flatten" href="index.html#phiml.math.flatten">flatten()</a></code></li>
</ul>
<p>Additionally, the <code>phiml.math.BoundDim</code> syntax for dimension renaming and retyping is enabled, e.g. <code>obj.dim.as_channel('vector')</code>.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shapable(metaclass=_ShapableType):
    &#34;&#34;&#34;
    Shapable objects can be stacked, concatenated and reshaped.

    To be considered `Shapable`, objects must be `Sliceable` and `Shaped` and implement

    * `__stack__()` or
    * `__concat__()` and `__expand__()`.

    Objects should additionally implement the other magic methods for performance reasons.

    **Usage in `phiml.math`:**

    Shapable objects can be used with the following functions in addition to what they inherit from being `Sliceable` and `Shaped`:

    * `phiml.math.stack`
    * `phiml.math.concat`
    * `phiml.math.expand`
    * `phiml.math.rename_dims`
    * `phiml.math.pack_dims`
    * `phiml.math.unpack_dim`
    * `phiml.math.flatten`

    Additionally, the `phiml.math.BoundDim` syntax for dimension renaming and retyping is enabled, e.g. `obj.dim.as_channel(&#39;vector&#39;)`.
    &#34;&#34;&#34;
    @staticmethod
    def __stack__(values: tuple, dim: Shape, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Stack all `values` into a single instance along the new dimension `dim`.

        This method can be implemented as a bound method or as a `staticmethod` (without the `self` argument).

        Args:
            values: `tuple` of `Shapable` objects to be stacked. `self` is included in that list at least once.
            dim: Single-dimension `Shape`. This dimension must not be present with any of the `values`.
                The dimension fulfills the condition `dim.size == len(values)`.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` representing the stacked slices.
            Its shape includes `dim` in addition to the dimensions present in `values`.
            If such a representation cannot be created because some values in `values` are not supported, returns `NotImplemented`.
        &#34;&#34;&#34;
        raise NotImplementedError

    @staticmethod
    def __concat__(values: tuple, dim: str, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Concatenate `values` along `dim`.

        This method can be implemented as a bound method or as a `staticmethod` (without the `self` argument).

        Args:
            values: Values to concatenate. `self` is included in that list at least once.
            dim: Dimension nams as `str`, must be present in all `values`.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` representing the concatenated values or `NotImplemented` to revert to default behavior for this object.
            When returning a valid object, the size of `dim` must be equal to the sum of all `dim` sizes in `values`.
            If such a representation cannot be created because some values in `values` are not supported, returns `NotImplemented`.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __expand__(self, dims: Shape, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Adds new dimensions to this object.
        The value of this object is constant along the new dimensions.

        Args:
            dims: Dimensions to add.
                They are guaranteed to not already be present in `shape(self)`.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __replace_dims__(self, dims: Tuple[str, ...], new_dims: Shape, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Exchange existing dimensions.
        This can be used to rename dimensions, change dimension types or change labels.

        Args:
            dims: Dimensions to be replaced.
            new_dims: Replacement dimensions as `Shape` with `rank == len(dims)`.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __pack_dims__(self, dims: Shape, packed_dim: Shape, pos: Union[int, None], **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Compresses multiple dimensions into a single dimension by concatenating the elements.
        Elements along the new dimensions are laid out according to the order of `dims`.

        The type of the new dimension will be equal to the types of `dims`.
        If `dims` have varying types, the new dimension will be a batch dimension.

        Args:
            dims: Dimensions to be compressed in the specified order.
            packed_dim: Single-dimension `Shape`.
            pos: Index of new dimension. `None` for automatic, `-1` for last, `0` for first.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __unpack_dim__(self, dim: str, unpacked_dims: Shape, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Decompresses a tensor dimension by unstacking the elements along it.
        The compressed dimension `dim` is assumed to contain elements laid out according to the order of `unpacked_dims`.

        Args:
            dim: Dimension to be decompressed.
            unpacked_dims: `Shape`: Ordered dimensions to replace `dim`, fulfilling `unpacked_dims.volume == shape(self)[dim].rank`.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __flatten__(self, flat_dim: Shape, flatten_batch: bool, **kwargs) -&gt; &#39;Shapable&#39;:
        &#34;&#34;&#34;
        Lays out all elements along a single dimension.
        This is equivalent to packing all dimensions.

        Args:
            flat_dim: Single dimension as `Shape`.
            flatten_batch: Whether to flatten batch dimensions as well.
            If `False`, batch dimensions are kept, only onn-batch dimensions are flattened.
            **kwargs: Additional keyword arguments required by specific implementations.
                Adding spatial dimensions to fields requires the `bounds: Box` argument specifying the physical extent of the new dimensions.
                Adding batch dimensions must always work without keyword arguments.

        Returns:
            New instance of `Shapable` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="phiml.math.magic.Shapable.__concat__"><code class="name flex">
<span>def <span class="ident">__concat__</span></span>(<span>values: tuple, dim: str, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Concatenate <code>values</code> along <code>dim</code>.</p>
<p>This method can be implemented as a bound method or as a <code>staticmethod</code> (without the <code>self</code> argument).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd>Values to concatenate. <code>self</code> is included in that list at least once.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Dimension nams as <code>str</code>, must be present in all <code>values</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> representing the concatenated values or <code>NotImplemented</code> to revert to default behavior for this object.
When returning a valid object, the size of <code>dim</code> must be equal to the sum of all <code>dim</code> sizes in <code>values</code>.
If such a representation cannot be created because some values in <code>values</code> are not supported, returns <code>NotImplemented</code>.</p></div>
</dd>
<dt id="phiml.math.magic.Shapable.__stack__"><code class="name flex">
<span>def <span class="ident">__stack__</span></span>(<span>values: tuple, dim: phiml.math._shape.Shape, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Stack all <code>values</code> into a single instance along the new dimension <code>dim</code>.</p>
<p>This method can be implemented as a bound method or as a <code>staticmethod</code> (without the <code>self</code> argument).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>values</code></strong></dt>
<dd><code>tuple</code> of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> objects to be stacked. <code>self</code> is included in that list at least once.</dd>
<dt><strong><code>dim</code></strong></dt>
<dd>Single-dimension <code>Shape</code>. This dimension must not be present with any of the <code>values</code>.
The dimension fulfills the condition <code>dim.size == len(values)</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> representing the stacked slices.
Its shape includes <code>dim</code> in addition to the dimensions present in <code>values</code>.
If such a representation cannot be created because some values in <code>values</code> are not supported, returns <code>NotImplemented</code>.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.magic.Shapable.__expand__"><code class="name flex">
<span>def <span class="ident">__expand__</span></span>(<span>self, dims: phiml.math._shape.Shape, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Adds new dimensions to this object.
The value of this object is constant along the new dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to add.
They are guaranteed to not already be present in <code>shape(self)</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
<dt id="phiml.math.magic.Shapable.__flatten__"><code class="name flex">
<span>def <span class="ident">__flatten__</span></span>(<span>self, flat_dim: phiml.math._shape.Shape, flatten_batch: bool, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Lays out all elements along a single dimension.
This is equivalent to packing all dimensions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>flat_dim</code></strong></dt>
<dd>Single dimension as <code>Shape</code>.</dd>
<dt><strong><code>flatten_batch</code></strong></dt>
<dd>Whether to flatten batch dimensions as well.</dd>
<dt>If <code>False</code>, batch dimensions are kept, only onn-batch dimensions are flattened.</dt>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
<dt id="phiml.math.magic.Shapable.__pack_dims__"><code class="name flex">
<span>def <span class="ident">__pack_dims__</span></span>(<span>self, dims: phiml.math._shape.Shape, packed_dim: phiml.math._shape.Shape, pos: Optional[int], **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Compresses multiple dimensions into a single dimension by concatenating the elements.
Elements along the new dimensions are laid out according to the order of <code>dims</code>.</p>
<p>The type of the new dimension will be equal to the types of <code>dims</code>.
If <code>dims</code> have varying types, the new dimension will be a batch dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to be compressed in the specified order.</dd>
<dt><strong><code>packed_dim</code></strong></dt>
<dd>Single-dimension <code>Shape</code>.</dd>
<dt><strong><code>pos</code></strong></dt>
<dd>Index of new dimension. <code>None</code> for automatic, <code>-1</code> for last, <code>0</code> for first.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
<dt id="phiml.math.magic.Shapable.__replace_dims__"><code class="name flex">
<span>def <span class="ident">__replace_dims__</span></span>(<span>self, dims: Tuple[str, ...], new_dims: phiml.math._shape.Shape, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Exchange existing dimensions.
This can be used to rename dimensions, change dimension types or change labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dims</code></strong></dt>
<dd>Dimensions to be replaced.</dd>
<dt><strong><code>new_dims</code></strong></dt>
<dd>Replacement dimensions as <code>Shape</code> with <code>rank == len(dims)</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
<dt id="phiml.math.magic.Shapable.__unpack_dim__"><code class="name flex">
<span>def <span class="ident">__unpack_dim__</span></span>(<span>self, dim: str, unpacked_dims: phiml.math._shape.Shape, **kwargs) ‑> <a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Decompresses a tensor dimension by unstacking the elements along it.
The compressed dimension <code>dim</code> is assumed to contain elements laid out according to the order of <code>unpacked_dims</code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dim</code></strong></dt>
<dd>Dimension to be decompressed.</dd>
<dt><strong><code>unpacked_dims</code></strong></dt>
<dd><code>Shape</code>: Ordered dimensions to replace <code>dim</code>, fulfilling <code>unpacked_dims.volume == shape(self)[dim].rank</code>.</dd>
<dt><strong><code>**kwargs</code></strong></dt>
<dd>Additional keyword arguments required by specific implementations.
Adding spatial dimensions to fields requires the <code>bounds: Box</code> argument specifying the physical extent of the new dimensions.
Adding batch dimensions must always work without keyword arguments.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New instance of <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
</dl>
</dd>
<dt id="phiml.math.magic.Shaped"><code class="flex name class">
<span>class <span class="ident">Shaped</span></span>
</code></dt>
<dd>
<div class="desc"><p>To be considered shaped, an object must either implement the magic method <code>__shape__()</code> or have a valid <code>shape</code> property.
In either case, the returned shape must be an instance of <code><a title="phiml.math.Shape" href="index.html#phiml.math.Shape">Shape</a></code>.</p>
<p>To check whether an object is <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code>, use <code>isinstance(obj, <a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a>)</code>.</p>
<p><strong>Usage in <code><a title="phiml.math" href="index.html">phiml.math</a></code>:</strong></p>
<p>The functions <code><a title="phiml.math.shape" href="index.html#phiml.math.shape">shape()</a></code> as well as dimension filters, such as <code><a title="phiml.math.spatial" href="index.html#phiml.math.spatial">spatial()</a></code> or <code><a title="phiml.math.non_batch" href="index.html#phiml.math.non_batch">non_batch()</a></code> can be called on all shaped objects.</p>
<p>See Also:
<code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code>, <code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Shaped(metaclass=_ShapedType):
    &#34;&#34;&#34;
    To be considered shaped, an object must either implement the magic method `__shape__()` or have a valid `shape` property.
    In either case, the returned shape must be an instance of `phiml.math.Shape`.

    To check whether an object is `Shaped`, use `isinstance(obj, Shaped)`.

    **Usage in `phiml.math`:**

    The functions `phiml.math.shape` as well as dimension filters, such as `phiml.math.spatial` or `phiml.math.non_batch` can be called on all shaped objects.

    See Also:
        `Sliceable`, `Shapable`
    &#34;&#34;&#34;

    def __shape__(self) -&gt; &#39;Shape&#39;:
        &#34;&#34;&#34;
        Returns the shape of this object.

        Alternatively, the shape can be declared via the property `shape`.

        Returns:
            `phiml.math.Shape`
        &#34;&#34;&#34;
        raise NotImplementedError

    @property
    def shape(self) -&gt; &#39;Shape&#39;:
        &#34;&#34;&#34;
        Alternative form of `__shape__()`.
        Implement either to be considered `Shaped`.

        Returns:
            `phiml.math.Shape`
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="phiml.math.magic.Shaped.shape"><code class="name">prop <span class="ident">shape</span> : Shape</code></dt>
<dd>
<div class="desc"><p>Alternative form of <code>__shape__()</code>.
Implement either to be considered <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.Shape" href="index.html#phiml.math.Shape">Shape</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def shape(self) -&gt; &#39;Shape&#39;:
    &#34;&#34;&#34;
    Alternative form of `__shape__()`.
    Implement either to be considered `Shaped`.

    Returns:
        `phiml.math.Shape`
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.magic.Shaped.__shape__"><code class="name flex">
<span>def <span class="ident">__shape__</span></span>(<span>self) ‑> phiml.math._shape.Shape</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the shape of this object.</p>
<p>Alternatively, the shape can be declared via the property <code>shape</code>.</p>
<h2 id="returns">Returns</h2>
<p><code><a title="phiml.math.Shape" href="index.html#phiml.math.Shape">Shape</a></code></p></div>
</dd>
</dl>
</dd>
<dt id="phiml.math.magic.Sliceable"><code class="flex name class">
<span>class <span class="ident">Sliceable</span></span>
</code></dt>
<dd>
<div class="desc"><p>Objects are considered sliceable if they are <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code> and implement <code>__getitem__</code> as defined below.</p>
<p>To enable the slicing syntax <code>obj.dim[slice]</code>, implement the <code>__getattr__</code> method as defined below.</p>
<p>Classes implementing <code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code> should override <code>__getattr__</code> to enable the special slicing syntax defined in <code><a title="phiml.math.magic.BoundDim" href="#phiml.math.magic.BoundDim">BoundDim</a></code>.</p>
<p><strong>Usage in <code><a title="phiml.math" href="index.html">phiml.math</a></code>:</strong></p>
<p>In addition to slicing, sliceable objects can be unstacked along one or multiple dimensions using <code><a title="phiml.math.unstack" href="index.html#phiml.math.unstack">unstack()</a></code>.</p>
<p>See Also
<code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code>, <code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sliceable(metaclass=_SliceableType):
    &#34;&#34;&#34;
    Objects are considered sliceable if they are `Shaped` and implement `__getitem__` as defined below.

    To enable the slicing syntax `obj.dim[slice]`, implement the `__getattr__` method as defined below.

    Classes implementing `Sliceable` should override `__getattr__` to enable the special slicing syntax defined in `BoundDim`.

    **Usage in `phiml.math`:**

    In addition to slicing, sliceable objects can be unstacked along one or multiple dimensions using `phiml.math.unstack`.

    See Also
        `Shapable`, `Shaped`
    &#34;&#34;&#34;

    def __getitem__(self, item) -&gt; &#39;Sliceable&#39;:
        &#34;&#34;&#34;
        Slice this object along one or multiple existing or non-existing dimensions.

        When overriding this function, make sure to first call `slicing_dict(self, item)` to sort slices by dimension.

        Args:
            item: `dict` mapping dimension names to the corresponding selections.
                Selections can be slices, indices, tuples, labels, bool tensors, int tensors or other custom types.
                All Sliceable object must support indexing by `int`, `slice`, `tuple`, `list`, `str`.

        Returns:
            Instance of the same class (or a compatible class) as `self`.
        &#34;&#34;&#34;
        raise NotImplementedError

    def __unstack__(self, dims: Tuple[str, ...]) -&gt; Tuple[&#39;Sliceable&#39;, ...]:
        &#34;&#34;&#34;
        Un-stack this object along one or multiple dimensions.
        Un-stacking along multiple dimensions is equal to first packing the dimensions and then unstacking along the packed dimension.

        Implementing this magic method is optional but the default implementation may be slow.

        Args:
            dims: Ordered `tuple` of dimension names along which to unstack this object.

        Returns:
            `tuple` of slices along `dims` or `NotImplemented` to revert to default behavior for this object.
        &#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="phiml.math.magic.Sliceable.__getitem__"><code class="name flex">
<span>def <span class="ident">__getitem__</span></span>(<span>self, item) ‑> <a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></span>
</code></dt>
<dd>
<div class="desc"><p>Slice this object along one or multiple existing or non-existing dimensions.</p>
<p>When overriding this function, make sure to first call <code><a title="phiml.math.magic.slicing_dict" href="#phiml.math.magic.slicing_dict">slicing_dict()</a>(self, item)</code> to sort slices by dimension.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>item</code></strong></dt>
<dd><code>dict</code> mapping dimension names to the corresponding selections.
Selections can be slices, indices, tuples, labels, bool tensors, int tensors or other custom types.
All Sliceable object must support indexing by <code>int</code>, <code>slice</code>, <code>tuple</code>, <code>list</code>, <code>str</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Instance of the same class (or a compatible class) as <code>self</code>.</p></div>
</dd>
<dt id="phiml.math.magic.Sliceable.__unstack__"><code class="name flex">
<span>def <span class="ident">__unstack__</span></span>(<span>self, dims: Tuple[str, ...]) ‑> Tuple[<a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a>, ...]</span>
</code></dt>
<dd>
<div class="desc"><p>Un-stack this object along one or multiple dimensions.
Un-stacking along multiple dimensions is equal to first packing the dimensions and then unstacking along the packed dimension.</p>
<p>Implementing this magic method is optional but the default implementation may be slow.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dims</code></strong></dt>
<dd>Ordered <code>tuple</code> of dimension names along which to unstack this object.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code>tuple</code> of slices along <code>dims</code> or <code>NotImplemented</code> to revert to default behavior for this object.</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="phiml.math" href="index.html">phiml.math</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="phiml.math.magic.slicing_dict" href="#phiml.math.magic.slicing_dict">slicing_dict</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="phiml.math.magic.BoundDim" href="#phiml.math.magic.BoundDim">BoundDim</a></code></h4>
<ul class="two-column">
<li><code><a title="phiml.math.magic.BoundDim.T" href="#phiml.math.magic.BoundDim.T">T</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_batch" href="#phiml.math.magic.BoundDim.as_batch">as_batch</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_channel" href="#phiml.math.magic.BoundDim.as_channel">as_channel</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_dual" href="#phiml.math.magic.BoundDim.as_dual">as_dual</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_instance" href="#phiml.math.magic.BoundDim.as_instance">as_instance</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_spatial" href="#phiml.math.magic.BoundDim.as_spatial">as_spatial</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.as_type" href="#phiml.math.magic.BoundDim.as_type">as_type</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.dual" href="#phiml.math.magic.BoundDim.dual">dual</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.exists" href="#phiml.math.magic.BoundDim.exists">exists</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.item_name_list" href="#phiml.math.magic.BoundDim.item_name_list">item_name_list</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.item_names" href="#phiml.math.magic.BoundDim.item_names">item_names</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.items" href="#phiml.math.magic.BoundDim.items">items</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.keys" href="#phiml.math.magic.BoundDim.keys">keys</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.labels" href="#phiml.math.magic.BoundDim.labels">labels</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.name_tensor" href="#phiml.math.magic.BoundDim.name_tensor">name_tensor</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.rename" href="#phiml.math.magic.BoundDim.rename">rename</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.replace" href="#phiml.math.magic.BoundDim.replace">replace</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.retype" href="#phiml.math.magic.BoundDim.retype">retype</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.size" href="#phiml.math.magic.BoundDim.size">size</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.size_or_1" href="#phiml.math.magic.BoundDim.size_or_1">size_or_1</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.type" href="#phiml.math.magic.BoundDim.type">type</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.unpack" href="#phiml.math.magic.BoundDim.unpack">unpack</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.unstack" href="#phiml.math.magic.BoundDim.unstack">unstack</a></code></li>
<li><code><a title="phiml.math.magic.BoundDim.volume" href="#phiml.math.magic.BoundDim.volume">volume</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.magic.OtherMagicFunctions" href="#phiml.math.magic.OtherMagicFunctions">OtherMagicFunctions</a></code></h4>
</li>
<li>
<h4><code><a title="phiml.math.magic.PhiTreeNode" href="#phiml.math.magic.PhiTreeNode">PhiTreeNode</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.magic.PhiTreeNode.__all_attrs__" href="#phiml.math.magic.PhiTreeNode.__all_attrs__">__all_attrs__</a></code></li>
<li><code><a title="phiml.math.magic.PhiTreeNode.__value_attrs__" href="#phiml.math.magic.PhiTreeNode.__value_attrs__">__value_attrs__</a></code></li>
<li><code><a title="phiml.math.magic.PhiTreeNode.__variable_attrs__" href="#phiml.math.magic.PhiTreeNode.__variable_attrs__">__variable_attrs__</a></code></li>
<li><code><a title="phiml.math.magic.PhiTreeNode.__with_attrs__" href="#phiml.math.magic.PhiTreeNode.__with_attrs__">__with_attrs__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.magic.Shapable" href="#phiml.math.magic.Shapable">Shapable</a></code></h4>
<ul class="two-column">
<li><code><a title="phiml.math.magic.Shapable.__concat__" href="#phiml.math.magic.Shapable.__concat__">__concat__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__expand__" href="#phiml.math.magic.Shapable.__expand__">__expand__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__flatten__" href="#phiml.math.magic.Shapable.__flatten__">__flatten__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__pack_dims__" href="#phiml.math.magic.Shapable.__pack_dims__">__pack_dims__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__replace_dims__" href="#phiml.math.magic.Shapable.__replace_dims__">__replace_dims__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__stack__" href="#phiml.math.magic.Shapable.__stack__">__stack__</a></code></li>
<li><code><a title="phiml.math.magic.Shapable.__unpack_dim__" href="#phiml.math.magic.Shapable.__unpack_dim__">__unpack_dim__</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.magic.Shaped" href="#phiml.math.magic.Shaped">Shaped</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.magic.Shaped.__shape__" href="#phiml.math.magic.Shaped.__shape__">__shape__</a></code></li>
<li><code><a title="phiml.math.magic.Shaped.shape" href="#phiml.math.magic.Shaped.shape">shape</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="phiml.math.magic.Sliceable" href="#phiml.math.magic.Sliceable">Sliceable</a></code></h4>
<ul class="">
<li><code><a title="phiml.math.magic.Sliceable.__getitem__" href="#phiml.math.magic.Sliceable.__getitem__">__getitem__</a></code></li>
<li><code><a title="phiml.math.magic.Sliceable.__unstack__" href="#phiml.math.magic.Sliceable.__unstack__">__unstack__</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.0</a>.</p>
</footer>
</body>
</html>
